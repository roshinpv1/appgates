#!/usr/bin/env python3
"""
Test script for Hybrid Pattern Validation System
Demonstrates the enhanced coverage and accuracy of combining LLM + Static patterns
"""

import os
import sys
import json
from pathlib import Path

# Add the current directory to the path so we can import our modules
sys.path.append(str(Path(__file__).parent))

from gates.utils.static_patterns import (
    get_static_patterns_for_gate, 
    get_pattern_statistics, 
    get_supported_technologies,
    STATIC_PATTERN_LIBRARY
)

def test_static_pattern_library():
    """Test the static pattern library functionality"""
    print("🧪 Testing Static Pattern Library")
    print("=" * 50)
    
    # Test pattern statistics
    stats = get_pattern_statistics()
    print(f"📊 Pattern Library Statistics:")
    print(f"   Total Gates: {stats['total_gates']}")
    print(f"   Total Technologies: {stats['total_technologies']}")
    print(f"   Total Patterns: {stats['total_patterns']}")
    print()
    
    # Test supported technologies
    technologies = get_supported_technologies()
    print(f"🔧 Supported Technologies: {', '.join(technologies)}")
    print()
    
    # Test pattern retrieval for different technology stacks
    test_cases = [
        (["java"], "Java Project"),
        (["python"], "Python Project"),
        (["javascript"], "JavaScript Project"),
        (["csharp"], "C# Project"),
        (["java", "javascript"], "Full-Stack Java + JS Project"),
        (["python", "javascript"], "Full-Stack Python + JS Project")
    ]
    
    for technologies, description in test_cases:
        print(f"📋 {description} ({', '.join(technologies)})")
        
        # Test a few key gates
        test_gates = ["STRUCTURED_LOGS", "AVOID_LOGGING_SECRETS", "AUTOMATED_TESTS"]
        
        for gate in test_gates:
            patterns = get_static_patterns_for_gate(gate, technologies)
            print(f"   {gate}: {len(patterns)} patterns")
            
            # Show sample patterns
            for i, pattern in enumerate(patterns[:2]):  # Show first 2 patterns
                print(f"     {i+1}. {pattern}")
            if len(patterns) > 2:
                print(f"     ... and {len(patterns) - 2} more patterns")
        print()

def test_hybrid_validation_simulation():
    """Simulate hybrid validation to show the benefits"""
    print("🚀 Hybrid Validation Simulation")
    print("=" * 50)
    
    # Simulate LLM patterns (what might be generated by LLM)
    llm_patterns = {
        "STRUCTURED_LOGS": [
            r'logger\.info\(',
            r'winston\.log\(',
            r'logging\.info\('
        ],
        "AVOID_LOGGING_SECRETS": [
            r'logger\.info.*password',
            r'console\.log.*token'
        ],
        "AUTOMATED_TESTS": [
            r'@Test',
            r'describe\(',
            r'def test_'
        ]
    }
    
    # Test different technology stacks
    test_scenarios = [
        {
            "name": "Java Spring Boot Project",
            "technologies": ["java"],
            "description": "Enterprise Java application with Spring Boot"
        },
        {
            "name": "Python Django Project", 
            "technologies": ["python"],
            "description": "Web application using Django framework"
        },
        {
            "name": "JavaScript Node.js Project",
            "technologies": ["javascript"],
            "description": "Backend API using Node.js and Express"
        },
        {
            "name": "Full-Stack Project",
            "technologies": ["java", "javascript"],
            "description": "Java backend with JavaScript frontend"
        }
    ]
    
    for scenario in test_scenarios:
        print(f"🎯 Scenario: {scenario['name']}")
        print(f"   Technologies: {', '.join(scenario['technologies'])}")
        print(f"   Description: {scenario['description']}")
        print()
        
        total_llm_patterns = 0
        total_static_patterns = 0
        total_combined_patterns = 0
        
        for gate_name, gate_llm_patterns in llm_patterns.items():
            # Get static patterns for this gate and technology
            static_patterns = get_static_patterns_for_gate(gate_name, scenario['technologies'])
            
            # Combine patterns (remove duplicates)
            combined_patterns = list(set(gate_llm_patterns + static_patterns))
            
            # Calculate statistics
            llm_count = len(gate_llm_patterns)
            static_count = len(static_patterns)
            combined_count = len(combined_patterns)
            improvement = ((combined_count - llm_count) / llm_count * 100) if llm_count > 0 else 0
            
            print(f"   {gate_name}:")
            print(f"     LLM Patterns: {llm_count}")
            print(f"     Static Patterns: {static_count}")
            print(f"     Combined Patterns: {combined_count}")
            print(f"     Improvement: +{improvement:.1f}%")
            print()
            
            total_llm_patterns += llm_count
            total_static_patterns += static_count
            total_combined_patterns += combined_count
        
        # Overall statistics
        overall_improvement = ((total_combined_patterns - total_llm_patterns) / total_llm_patterns * 100) if total_llm_patterns > 0 else 0
        print(f"   📈 Overall Results:")
        print(f"     Total LLM Patterns: {total_llm_patterns}")
        print(f"     Total Static Patterns: {total_static_patterns}")
        print(f"     Total Combined Patterns: {total_combined_patterns}")
        print(f"     Overall Improvement: +{overall_improvement:.1f}%")
        print()
        print("-" * 50)

def test_pattern_quality():
    """Test the quality and coverage of patterns"""
    print("🔍 Pattern Quality Analysis")
    print("=" * 50)
    
    # Analyze pattern distribution by gate
    print("📊 Pattern Distribution by Gate:")
    stats = get_pattern_statistics()
    
    for gate_name, pattern_count in stats['patterns_by_gate'].items():
        print(f"   {gate_name}: {pattern_count} patterns")
    
    print()
    
    # Analyze pattern distribution by technology
    print("🔧 Pattern Distribution by Technology:")
    for tech, pattern_count in stats['patterns_by_technology'].items():
        print(f"   {tech}: {pattern_count} patterns")
    
    print()
    
    # Test pattern specificity for security gates
    print("🔒 Security Gate Pattern Analysis:")
    security_gates = ["AVOID_LOGGING_SECRETS"]
    
    for gate in security_gates:
        print(f"   {gate}:")
        gate_patterns = STATIC_PATTERN_LIBRARY.get(gate, {})
        
        for tech, patterns in gate_patterns.items():
            if tech not in ['standard_logging', 'structured_logging', 'framework_logging', 'all_languages']:
                print(f"     {tech}: {len(patterns)} patterns")
                # Show sample security patterns
                for i, pattern in enumerate(patterns[:1]):
                    print(f"       Sample: {pattern}")
    
    print()

def main():
    """Main test function"""
    print("🧪 Hybrid Pattern Validation System Test")
    print("=" * 60)
    print()
    
    try:
        # Test 1: Static Pattern Library
        test_static_pattern_library()
        print()
        
        # Test 2: Hybrid Validation Simulation
        test_hybrid_validation_simulation()
        print()
        
        # Test 3: Pattern Quality Analysis
        test_pattern_quality()
        print()
        
        print("✅ All tests completed successfully!")
        print()
        print("🎉 Key Benefits of Hybrid Validation:")
        print("   • Enhanced pattern coverage across all technology stacks")
        print("   • LLM provides context-aware, project-specific patterns")
        print("   • Static library ensures comprehensive, battle-tested patterns")
        print("   • Cross-validation increases accuracy and confidence")
        print("   • Technology-specific filtering improves relevance")
        print("   • Backward compatibility with existing LLM-only validation")
        
    except Exception as e:
        print(f"❌ Test failed with error: {e}")
        import traceback
        traceback.print_exc()
        return 1
    
    return 0

if __name__ == "__main__":
    sys.exit(main()) 